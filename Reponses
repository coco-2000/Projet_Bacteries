#Projet programmation orientée objet (SSV)

##REPONSES du groupe *No groupe* (Emma Boehly & Constance De Trogoff)

*************************************************
##Q1.1


- Les opérateurs > et & utilisent des fonctionnalités qui ont déjà été
programmé dans les methodes contains et isColliding, il suffit donc
leur faire retourner les résultats de ces dernières methodes.


*************************************************
##Q1.2

Nous avons utilisé la surcharge externe pour les opérateur > et & car il est préférable d'utiliser
la surcharge externe lorsqu'elle ne fait ni appel aux getteurs de la classe ni aux attributs private.
Or les opérateurs > et & utilisent des methodes publiques de la classe CircularBody.

Nous avons utilisé la surcharge externe pour l'opérateur << car on ne cherche pas à modifier la classe ostream.
De plus il est préférable lorsque c'est possible de faire une surcharge externe.

*************************************************
##Q1.3


- Nous avons passés par référence constante les arguments de type
CircularBody des fonctions contains et isColliding, des operateurs
>, = et & et du constructeur de copie ainsi que les arguments de type Vec2d
de l'accesseur de position, des methodes move et contains et de l'opérateur
> car ces objets pouvant être de grande taille, les passer par référence
permet d'éviter de les copier. Les désigner comme constants permet d'éviter
qu'ils soient modifiés par erreurs.

*************************************************
##Q1.4

- Nous avons déclaré la fonctions isColliding, les deux fonctions contains,
les accesseurs de postion et de rayon ainsi que les operateurs > et & en
constants car ils ne modifiaient aucuns attribut de la classe

*************************************************
##Q2.1

Pour modéliser l'assiette comme un corps circulaire, nous avons fait en sorte d'établir
une relation d'héritage entre les 2 classes : PetriDish herite de CircularBody.
Elle est donc un CircularBody.

*************************************************
##Q2.2

addBacterium et addNurtiment ne sont pas considérées comme const car elles modifient
les attributs. De même pour la methode update qui pourrait engendré des modifications sur les attributs

En revanche, la methode drawOn peut être considérée comme const car elle s'occupe simplement de dessiner l'assiette de Petri.

*************************************************
##Q2.3

Pour empecher la copie, on place "= delete" à la fin du prototype du constructeur de copie.
Pour supprimer l'usage de l'opérateur d'affectation, on place "= delete"
à la fin prototype de la surcharge de l'operateur =.

*************************************************
##Q2.4

Les bacteries et les nutriments n'existant pas en dehors de l'assiette de Petri,
c'est l'assiette de Petri qui doit gérer leur destruction.
Ainsi, lors de la destruction d'une assiette de Petri, il faut également que les bactéries
et les nutriments vers lesquels elle pointe soient détruis.
Le destructeur de la classe PetriDish doit donc faire appel à la methode reset() qui désalloue tous les pointeurs.

*************************************************
##Q2.5
Comme pour le moment dessiner un Lab c'est aussi dessiner une assiette de Petri,
la methode Lab::drawOn devrait faire appel à la methode PetriDish::drawOn qui
permet de dessiner l'assiette de Petri.
De même, faire évoluer un Lab c'est simplement faire évoluer son assiette de Petri
donc la methode Lab::update devrait faire appel à la methode PetriDish::update
qui permet de faire évoluer l'assiette.

*************************************************
##Q2.7

Si la classe Nutriment est un type de CircularBody alors on peut la considérer
comme une sous-classe de la super-classe CircularBody. Il s'agit alors d'établir
une relation d'héritage entre les 2 classes : Nutriment hérite de CircularBody.

*************************************************
##Q2.8

Le type double est couramment utilisé et pour des éléments très différents.
Son sens est donc très général et il peut être difficile de comprendre à
quel type d'objets il fait référence. L'utilisation du type Quantity permet de
spécifier ce qu'il représente et établit un lien sémantique entre les
différents éléments auxquels ils s'appliquent.

*************************************************

##Q2.9

La méthode getEnv renvoie une instance de type Lab sur laquelle s'applique la
méthode addNutriment, or celle-ci a été implémenté dans la classe PetriDish.
Il faut donc crée une nouvelle méthode addNutriment cette fois dans la classe
Lab qui appellera celle de PetriDish pour permettre l'ajout de nutriments à
l'assiette de Petri lorsque l'on appuie sur la touche 'N'.

On veut dessiner les nutriments placés dans un tableau qui est un attribut de
la classe PetriDish qui elle-même est utilisée par la classe Lab.
La méthode drawOn de la classe Lab fait appel à la méthode drawOn de la classe
PetriDish. C'est donc cette dernière que l'on doit modifier pour qu'elle boucle sur
l'ensemble du tableau de nutriments en appelant à chaque fois la méthode
drawOn de la classe Nutriment qui elle se charge de dessiner un nutriment.

*************************************************

##Q2.10

Les nutriments ne croissent que si la température leur convient, la méthode
Nutriment::update qui les fait évoluer doit donc être appelé que si les conditions
portant sur la température sont respectées. Il suffit donc de tester la température
dans la méthode PetriDish::update et d'appeller la méthode Nutriment::update que si
la température convient.

*************************************************

##Q2.11

Pour que la croissance des nutriments deviennent visibles il faut que leur rayon
soit mis-à-jour. Il s'agit donc d'appeler la fonction setQuantity de la classe
Nutriment dans la fonction Nutriment::update qui va modifier à la fois l'attribut
quantité et l'attribut rayon du nutriment.

*************************************************

##Q2.12

Dans le fichier Application.cpp, les touches PageUp et PageDown appelle respectivement
les méthodes increaseTemperature et decreaseTemperature associées à la classe Lab, il
faut donc les implémenter de manière à ce que ces méthodes augmentent et diminuent la
température de l'assiette de Petri. Cependant, la température est un attribut de la classe
PetriDish auquel la classe Lab n'a pas accès. Il faut donc implémenter des méthodes
increaseTemperature et decreaseTemperature dans la classe PetriDish également qui seront
appelées par les méthodes de la classe Lab et seront en charge de modifier la température
de l'assiette.



Quelles méthodes devez vous ajouter et dans quelles classes pour que appuyer
sur 'PgUp' ou 'PgDn' permette respectivement d'augmenter ou diminuer la température
de l'assiette de ["petri dish"]["temperature"]["delta"] (un double) ? Quelles méthode(s)
devez vous également ajouter et à quelle(s) classe(s) pour que les touches 'R' et 'C'
permettent aussi (en plus de ce qu'elles font) de réinitialiser l'attribut température à
la valeur du fichier de configuration (["petri dish"]["temperature"]["default"])
tout en évitant toute duplication de code ? Répondez à ces question dans votre fichier REPONSES, programmez les méthodes suggérées et décommentez les lignes 532, 547 et 814 de Application.cpp.






