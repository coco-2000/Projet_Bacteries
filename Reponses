#Projet programmation orientée objet (SSV)

##REPONSES du groupe *No groupe* (Emma Boehly & Constance De Trogoff)

*************************************************
##Q1.1


- Les opérateurs > et & utilisent des fonctionnalités qui ont déjà été
programmé dans les methodes contains et isColliding, il suffit donc
leur faire retourner les résultats de ces dernières methodes.


*************************************************
##Q1.2

Nous avons utilisé la surcharge interne pour les opérateur > et &.

Pour l'opérateur > qui s'utilise comme body > point et body1 > body2, la surchage interne a été choisie car
il existe une asymétrie entre les 2 opérandes ; il s'agit de vérifier si l'une est contenue dans l'autre.
Il n'y a donc pas de raison de passer les 2 opérandes en paramètre sur un même pied d'égalité.

Les surcharges & et > appellent les methodes contains et isColliding et nous avons fait en sorte que
la surcharge respecte la structure deja employée par ces methodes qui instaurent une asymétrie entre les opérandes.


Nous avons utilisé la surcharge externe pour l'opérateur << car on ne cherche pas à modifier la classe ostream.
De plus il est préférable lorsque c'est possible de faire une surcharge externe.


*************************************************
##Q1.3


- Nous avons passés par référence constante les arguments de type
CircularBody des fonctions contains et isColliding, des operateurs
>, = et & et du constructeur de copie ainsi que les arguments de type Vec2d
de l'accesseur de position, des methodes move et contains et de l'opérateur
> car ces objets pouvant être de grande taille, les passer par référence
permet d'éviter de les copier. Les désigner comme constants permet d'éviter
qu'ils soient modifiés par erreurs.

*************************************************
##Q1.4

- Nous avons déclaré la fonctions isColliding, les deux fonctions contains,
les accesseurs de postion et de rayon ainsi que les operateurs > et & en
constants car ils ne modifiaient aucuns attribut de la classe

*************************************************
##Q2.1

PetriDish herite de CircularBody. Elle est donc un CircularBody.

*************************************************
##Q2.2

addBacterium et addNurtiment ne sont pas considérées comme const car elles modifient
les attributs.

*************************************************
##Q2.3

Pour empecher la copie, on place "= delete" à la fin du prototype du constructeur de copie.
Pour supprimer l'usage de l'opérateur d'affectation,
on place "= delete" à la fin prototype de la surcharge de l'operateur =.

*************************************************
##Q2.4

Lors de la destruction d'une assiette de Petri, il faut également que les bactéries
et les nutriments vers lesquels elle pointe soient détruis.
Le destructeur de la calsse PetriDish doit donc faire appel à la methode reset()

*************************************************
##Q2.5

Comme pour le moment, faire évoluer un Lab c'est simplement faire évoluer son assiette de Petri unique
et le dessiner c'est aussi dessiner cette assiette de Petri, la methode Lab::drawOn devrait faire appel
à la methode PetriDish::drawOn qui permet de dessiner l'assiette de Petri














