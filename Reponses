#Projet programmation orientée objet (SSV)

##REPONSES du groupe *No groupe* (Emma Boehly & Constance De Trogoff)

*************************************************
##Q1.1


- Les opérateurs > et & utilisent des fonctionnalités qui ont déjà été
programmé dans les methodes contains et isColliding, il suffit donc
leur faire retourner les résultats de ces dernières methodes.


*************************************************
##Q1.2

Nous avons utilisé la surcharge externe pour les opérateur > et & car il est préférable d'utiliser
la surcharge externe lorsqu'elle ne fait ni appel aux getteurs de la classe ni aux attributs private.
Or les opérateurs > et & utilisent des methodes publiques de la classe CircularBody.

Nous avons utilisé la surcharge externe pour l'opérateur << car on ne cherche pas à modifier la classe ostream.
De plus il est préférable lorsque c'est possible de faire une surcharge externe.

*************************************************
##Q1.3


- Nous avons passés par référence constante les arguments de type
CircularBody des fonctions contains et isColliding, des operateurs
>, = et & et du constructeur de copie ainsi que les arguments de type Vec2d
de l'accesseur de position, des methodes move et contains et de l'opérateur
> car ces objets pouvant être de grande taille, les passer par référence
permet d'éviter de les copier. Les désigner comme constants permet d'éviter
qu'ils soient modifiés par erreurs.

*************************************************
##Q1.4

- Nous avons déclaré la fonctions isColliding, les deux fonctions contains,
les accesseurs de postion et de rayon ainsi que les operateurs > et & en
constants car ils ne modifiaient aucuns attribut de la classe

*************************************************
##Q2.1

Pour modéliser l'assiette comme un corps circulaire, nous avons fait en sorte d'établir
une relation d'héritage entre les 2 classes : PetriDish herite de CircularBody.
Elle est donc un CircularBody.

*************************************************
##Q2.2

addBacterium et addNurtiment ne sont pas considérées comme const car elles modifient
les attributs. De même pour la methode update qui pourrait engendré des modifications sur les attributs

En revanche, la methode drawOn peut être considérée comme const car elle s'occupe simplement de dessiner l'assiette de Petri.

*************************************************
##Q2.3

Pour empecher la copie, on place "= delete" à la fin du prototype du constructeur de copie.
Pour supprimer l'usage de l'opérateur d'affectation, on place "= delete"
à la fin prototype de la surcharge de l'operateur =.

*************************************************
##Q2.4

Les bacteries et les nutriments n'existant pas en dehors de l'assiette de Petri,
c'est l'assiette de Petri qui doit gérer leur destruction.
Ainsi, lors de la destruction d'une assiette de Petri, il faut également que les bactéries
et les nutriments vers lesquels elle pointe soient détruis.
Le destructeur de la classe PetriDish doit donc faire appel à la methode reset() qui désalloue tous les pointeurs.

*************************************************
##Q2.5
Comme pour le moment dessiner un Lab c'est aussi dessiner une assiette de Petri,
la methode Lab::drawOn devrait faire appel à la methode PetriDish::drawOn qui
permet de dessiner l'assiette de Petri.
De même, faire évoluer un Lab c'est simplement faire évoluer son assiette de Petri
donc la methode Lab::update devrait faire appel à la methode PetriDish::update
qui permet de faire évoluer l'assiette.

*************************************************
##Q2.7

Si la classe Nutriment est un type de CircularBody alors on peut la considérer
comme une sous-classe de la super-classe CircularBody. Il s'agit alors d'établir
une relation d'héritage entre les 2 classes : Nutriment hérite de CircularBody.

*************************************************
##Q2.8

Le type double est couramment utilisé et pour des éléments très différents.
Son sens est donc très général et il peut être difficile de comprendre à
quel type d'objets il fait référence. L'utilisation du type Quantity permet de
spécifier ce qu'il représente et établit un lien sémantique entre les
différents éléments auxquels ils s'appliquent.

*************************************************
##Q2.9

La méthode getEnv renvoie une instance de type Lab sur laquelle s'applique la
méthode addNutriment, or celle-ci a été implémenté dans la classe PetriDish.
Il faut donc crée une nouvelle méthode addNutriment cette fois dans la classe
Lab qui appellera celle de PetriDish pour permettre l'ajout de nutriments à
l'assiette de Petri lorsque l'on appuie sur la touche 'N'.

On veut dessiner les nutriments placés dans un tableau qui est un attribut de
la classe PetriDish qui elle-même est utilisée par la classe Lab.
La méthode drawOn de la classe Lab fait appel à la méthode drawOn de la classe
PetriDish. C'est donc cette dernière que l'on doit modifier pour qu'elle boucle sur
l'ensemble du tableau de nutriments en appelant à chaque fois la méthode
drawOn de la classe Nutriment qui elle se charge de dessiner un nutriment.

*************************************************
##Q2.10

Les nutriments ne croissent que si la température leur convient, la méthode
Nutriment::update qui les fait évoluer doit donc être appelé que si les conditions
portant sur la température sont respectées. Il suffit donc de tester la température
dans la méthode PetriDish::update et d'appeller la méthode Nutriment::update que si
la température convient.

*************************************************
##Q2.11

Pour que la croissance des nutriments deviennent visibles il faut que leur rayon
soit mis-à-jour. Il s'agit donc d'appeler la fonction setQuantity de la classe
Nutriment dans la fonction Nutriment::update qui va modifier à la fois l'attribut
quantité et l'attribut rayon du nutriment.

*************************************************
##Q2.12

Dans le fichier Application.cpp, les touches PageUp et PageDown appelle respectivement
les méthodes increaseTemperature et decreaseTemperature associées à la classe Lab, il
faut donc les implémenter de manière à ce que ces méthodes augmentent et diminuent la
température de l'assiette de Petri. Cependant, la température est un attribut de la classe
PetriDish auquel la classe Lab n'a pas accès. Il faut donc implémenter des méthodes
increaseTemperature et decreaseTemperature dans la classe PetriDish également qui seront
appelées par les méthodes de la classe Lab et seront en charge de modifier la température
de l'assiette.

Pour  réinitialiser l'attribut température nous avons crée une méthode init_temperature
dans la classe Petridish ainsi que Lab (qui appelle celle de PetriDish) qui affecte à
l'attribut température sa valeur par défaut. Dès lors, il a suffit d'appeler init_temperature
dans la fonction Lab::reset (qui est elle-même appelé lorsqu'on appuie sur la touche 'R') et dans
la fonction du fichier Application.cpp qui gère la touche 'C'.

*****************************************************
#Q3.1

Les classes Lab, PetriDish et Nutriment devraient hériter des classes Drawable et Updatable car
elles possèdent les methodes drawOn et update. Cela permet de rendre le code plus générique et
de mieux structurer le programme. On sait directement quelles sont les classes qui seront dessinées
et quelles sont les classes qui évolueront lors de l'affichage
avec le temps.

*****************************************************
#Q3.2

pas besoin de mettre "virtual" devant le prototype des methodes drawOn et update de la superclasse
Nutriment car ces methodes sont déjà virtuelles et peuvent donc être redéfinie dans les sous classe
de Nutriment

*****************************************************
#Q3.3

Il est nécessaire d'avoir dans la classe Nutriment le prototype de getConfig car de nombreuses
methodes de nutriment font appel à getConfig
Comme la méthode getConfig ne pas être définie concrètement au niveau de la classe Nutriment
(car  elle est spécifique à ses sous classes), elle devra donc être codée
comme une méthode virtuelle pure.
Elle sera ensuite redéfinie dans chaque sous classe
Nutriment A et Nutriment B de manière spécifique.

*****************************************************
#Q3.4

Grace au polymorphisme, les methodes update et drawOn appellent la methode getConfig au moment de l'execution
en fonction de s'il s'agit d'une instance de Nutriment A ou d'une instance de Nutriment B.
En effet, la methode getConfig est une méthode virtuelle et s'exerce sur les instances réellement concernées
grâce aux pointeurs de nutriment de la classe Petridish.
Ainsi les conditions nécessaires pour la résolution dynamique des liens sont remplies et l'affichage graphique
peut se faire de manière spécifique pour les nutriments A et nutriments B sans qu'il soit necessaire de modifier drawOn et update

*****************************************************
#Q3.5

La methode update de Lab doit appeler la methode update de NutrimentGenerator
pour lui permettre de générer des sources de nutriments dans l'assiette de Petri
qui lui est associée

*****************************************************
##Q3.6


Nous avons dû programmer une méthode set permettant d'attribuer une valeur au nombre,
celle-ci doit donc se charger de vérifier le plafonnage de la valeur entre la borne
inférieure et la borne supérieure. Il suffit alors de l'appeler dès que la valeur doit
être modifiée (dans le constructeur par exemple).

*************************************************
##Q3.7

Pour que ces méthodes puissent être accessible même en sans qu'aucune instance ne soit
créée (uniquement au travers du nom de la classe), il faut les déclarer comme attributs
de classe avec le mot clé static. On y accède ensuite au travers de l'opérateur de
résolution de portée.

*************************************************
##Q3.8

Les bacteries sont dessinables, simulables et sont des corps circulaires. La classe bacterie hérite donc de Drawable,
Ubdatable et de CircularBody

On a choisi de mettre les methodes move, divide, clone et mutate en protected dans Bacterie
car les bacteries devraient pouvoir se déplacer,  effectuer la division cellulaire et les mutations d'elle-même
sans avoir besoin du monde exterieur.
De plus ces methodes seront certainement appelées par la methode update qui est propre à la bacterie.

La methode drawOn a ete déclaré const car elle ne modifie pas les attributs de la bactérie

*************************************************
##Q3.9

la methode void move(sf::Time dt) doit être virtuelle pure car nous ne pouvons pas définir
cette fonctionnalité de façon générique pour une bactérie quelconque.

*************************************************
##Q3.10

oui la méthode getConfig doit être virtuelle pure car elle créé un racourci pour accéder à des
propriétés spécifiques aux différents types de bactéries.

*************************************************
##Q3.11

Pour retrouver la couleur SFML de la bactérie à partir de son attribut de type MutableColor
il faut appeller la methode get() de MutableColor qui retourne la couleur associée

**************************************************
##Q3.12

Le fait qu'aucune méthode de déplacement concrète n'existe encore n'est pas un frein à l'écriture de la méthode update
car move est une méthode virtuelle pure qui sera redéfinie dans les sous classe de bacterium.
Bacterium est une classe abstraite donc elle n'est pas instanciable. Grace au polymorphisme, la methode move sera masquée
par celle redéfinie dans l'une des sous classe

**************************************************
##Q3.13

La classe PetriDish ne donne pas d'accès à sa collection de nutriment. On a donc décidé de créer
une méthode getNutrimentColliding dans PetriDish qui sera appelée par la methode getNutrimentColliding
de Lab et qui pourra ainsi avoir accés aux Nutriments de PetriDish

**************************************************
##Q3.14

Pour permettre la simulation de l'évolution des bactéries, la methode update de PetriDish doit appeler la méthode update de bacterie
Pour plus de modularité, on a créé 2 methodes privées dans PetriDish :
update_bacteries et update_nutriments qui sont appelées par la methode update de PetriDish
De même, la methode drawOn de PertriDish doit appeler la methode drawOn de bacterie

**************************************************
##Q3.15

C'est la PetriDish qui a la propriété des bacteries et des nutriments.
C'est donc la methode update de PetriDish qui doit se charger de la mort des bacteries
et de la disparition des nutriments.
Création de la methode isEmpty() dans la classe Nutriment pour savoir si la quantite de nutriment est nulle.
La methode update de PetriDish appelle donc  la methode en_vie() de bacterium pour savoir
si elle n'a plus d'énergie ainsi qye la methode isEmpty() de nutriment

**************************************************
##Q3.16

La classe DiffEqFunction est une classe abstraite car elle contient une méthode f
virtuelle pure. Cette méthode permet de modéliser une force ce dont nous avons justement
besoin. Il s'agit donc de créer une nouvelle classe (MRU en l'occurence) qui hérite de
DiffEqFunction et qui définit la méthode f selon nos conditions, autrement dit elle
renvoit un vecteur force nulle indépendamment des vitesses et positions de l'instance (on
peut d'ailleurs surcharger la méthode f en ne lui faisant pas prendre de paramètres).
Ensuite, nous pouvons ajouter un attribut equation de type MRU à la classe SimpleBacterium
(car elle a une équation qui régit son déplacement = composition) qui nous permet
d'utiliser la méthode f pour déterminer le déplacement de l'instance de type
SimpleBacterium.

**************************************************
##Q3.17

t doit être déclaré en tant qu'attribut de classe car chaque instance de SimpleBacterium
possède son propre compteur qui évolue en fonction du temps de vie de l'instance.
On peut donc l'initialiser dans le constructeur avec la méthode uniform. Ce sera ensuite
la méthode move qui le mettra à jour à chaque déplacement de l'instance.

**************************************************
##Q3.18

L'angle de direction est relié à la direction de l'instance, on le déclare comme
attribut de classe Bacterium. On peut donc l'initialiser dans le constructeur de
Bacterium. Cependant, comme l'angle de direction est lié à la direction, il faut
l'initialiser dans le corps du constructeur en convertissant le vecteur direction
en angle.
La mise à jour de l'angle se fait uniquement lorsque la direction change, autrement
dit lorsque la bactérie rebondit sur une paroi. C'est donc la fonction
Bacterium::CollisionPetri qui doit mettre à jour l'angle (en même temps que la direction)

**************************************************
##Q3.19

Pour permettre de calculer le score d'une position donnée de l'assiette, il faut que
la méthode Lab::getPositionScore appelle une méthode de PetriDish, on l'occurence
on a crée PetriDish::getPositionScore. Celle-ci pourra faire une boucle sur l'ensemble
des instances de son tableau de nutriment calculant pour chacun d'eux le score
associée à la position et faisant leur somme, qu'elle peut ensuite retourner à la classe
Lab.

**************************************************
##Q3.20

On a crée l'attribut tps_basculement dans la classe SimpleBacterium qui est mis
à jour au début de la fonction SimpleBacterium::move et réinitialisé dans
SimpleBacterium::tentative_basculement lorsque le basculement est effectué.
L'attribut tps_basculement sert pour le basculement, une fonctionnalité
proposée par la classe SimpleBacterium. Il est donc plus cohérent de le déclarer
dans SimpleBacterium comme c'est la seule classe à l'utiliser.

On a crée l'attribut ancien_score dans la classe Bacterium car sa mise à jour s'initie
dans la classe PetriDish et s'applique sur une bactérie. Le score étant un attribut
pouvant être réutilisé pour n'importe quel instance de bactérie, il semblait plus
cohérent de définir une fonction setScore dans Bacterium qui met à jour la valeur de
l'ancien_score plutôt que de juste protoyper la méthode dans Bacterium pour la définir dans
SimpleBacterium. Aussi, comme on utilise l'attribut ancien_score dans Bacterium, nous
l'avons déclaré dans cette classe.


**************************************************
##Q3.21

La méthode de mutation est commune à toutes les bactéries et agit sur l'attribut
param_mutables qui est un attribut déclarer dans la classe Bacterium. Pour éviter
d'avoir à répliquer un même code dans différentes sous-classe, il vaut donc mieux que
la méthode de mutation, mutate appartiennent à la classe Bacterium.

**************************************************
##Q3.22

Puisque toutes les bactéries possèdent un attribut param_mutables, elles peuvent toutes
avoir besoin d'accéder ou d'ajouter un nouveau paramètre mutable. Par conséquent, les
méthodes addProperty et getProperty peuvent être codé dans la classe Bacterium

**************************************************
##Q3.23

Puisque la méthode de division est la même pour toutes les bactéries, on implémente la
méthode clone dans la classe Bacterium. Celle-ci se charge d'appeler une méthode clone
dans la classe SimpleBacterium qui renvoie un pointeur sur une copie de l'instance
courante (donc du même type que la bactérie qui se divise),puis elle effectue toutes
les modifications induites par la division (energie, mutation, direction) avant de
retourner elle aussi un pointeur sur la bactérie nouvellement créée.

**************************************************
##Q4.1

TwitchingBacterium est une bacterie. ELle doit donc hériter de la classe Bacterium
La classe Bacterium herite déja des classes Drawable et Updatable. Il n'est pas nécessaire de les rajouter.

**************************************************
##Q4.2

Redéfinir la méthode getConfig héritée de la classe bacterium.

**************************************************
##Q4.3
Toutes les méthodes virtuelles pures héritées de Bacterium devront être redéfinies pour que la classe
TwitchingBacterium puisse être instanciable.

Question : divisiion et directions
facteurs de déperdition d'énergie
BacteriaTest toujours la








